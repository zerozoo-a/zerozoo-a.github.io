---
title: 운영체제의 메모리 관리 기법
date: 2023-12-28 22:01:21
coverURL: 
---
<br />
<br />
<br />

# 메모리 관리

## 메모리 관리 기법들

- 반입 기법
- 배치 기법
- 할당 기법
- 교체 기법

### 반입 기법 

<a href="/blog/temp/os-memory-page-and-segment/">페이지나 세그먼트</a>가 보조 기억장치(ex: HDD, SSD)에서 주기억장치로 적재될 때,
어느 시기에 적재 할 것인지를 결정하는 전략입니다.

반입 기법은 다시 2가지로 나뉩니다.

- 요구 반입 
  - 가장 일반적입니다
  - 프로그램이 특정 메모리를 요구할 때 요구된 페이지를 주 메모리로 반입합니다.
- 예측 반입
  - 시스템이 필요 할 것으로 예상되는 메모리를 미리 주 메모리로 반입합니다.


### 배치 기법

배치 기법은 프로그램이나 작업을 메모리에 할당하는 방법을 의미합니다.

배치는 말그대로 적당한 프로그램을 메모리의 **어디에 배치** 할 것인지를 다룹니다.


배치 기법은 다시 3가지로 나뉩니다.

- First-Fit (첫 번째 적합) 
  - 배치할 메모리 공간중 가장 처음 만나는 적재 가능한 공간에 적재합니다.
  - 탐색시간이 매우 빠릅니다. 메모리 앞부분에 작은 빈 공간을 많이 만들 수 있습니다.
- Best-Fit (최적 적합) 
  - 남은 메모리 공간중 가장 빈공간이 적은 공간에 적재합니다.
  - 모든 공간을 탐색하기 때문에 타 방법에 비해 시간이 걸립니다.
  - 외부 단편화가 줄어들지만 사용하기 힘든 매우 작은 공간이 생겨날 수 있습니다.

- Worst-Fit (최악 적합)
  - 가장 큰 공간에 적재합니다. 
  - 큰 공간이 다 차게되면 빈 공간을 찾기 어려워집니다.

### 할당 기법

실행해야 할 프로세스를 주기억장치에 어떤 방법으로
할당할 것인지 결정하는 기법을 의미합니다.

할당 기법은 다시 2가지로 나뉩니다.

  - 연속 할당 
    - 하나의 프로세스가 필요로 하는 메모리를 메모리 상의 연속적인 위치에 할당합니다.

    연속 할당은 다시 3가지로 나뉘어집니다.

      - 단일 분할 할당
        - 모든 사용 가능한 메모리가 하나의 큰 블록으로 할당됩니다.
        - 가장 간단하고, 비효율적입니다..
      - 고정 분할 할당
        - 메모리를 고정된 크기의 분할로 나눕니다.
        - 각 분할당 하나의 프로세스를 매핑합니다.
      - 동적 분할 할당
        - 프로세스 요구에 따라 동적 분할 합니다.

    
  - 분산 할당
    - 페이징
    - 세그멘테이션
    - <a href="/blog/Engineer-Information-Processing/os-memory-page-and-**segment**/"> 페이징과 세그멘테이션 </a>


  - <a href="/blog/Engineer-Information-Processing/os-address-translation/">논리 주소와 물리주소, 주소 사상 기법</a>

## 교체 기법

교체 기법(Replacement Algorithms)은 운영 체제가 시스템의 사용 가능한 메모리가 부족할 때, 어떤 페이지(또는 세그먼트)를 제거하고 새로운 페이지를 로드할지 결정하는 방법을 말합니다.

- 주기억 장치에 있는 프로세스 중 어떤 프로세스를 제거할 것인지 결정하는 기법
- 새로운 페이지를 할당하기 위해 현재 할당된 페이지 중 어느 것과 교체할지 결정
- 메모리 교체 대상을 결정한다.
- 교체 기법의 유형으로는 
  - FIFO (First-In, First-Out)
    - 원리: 가장 오래 전에 메모리에 로드된 페이지를 가장 먼저 교체
    - 특징: 구현이 간단하나, 중요한 페이지가 교체되는 경우가 있을 수 있음 
  - LRU (Least Recently Used)
    - 원리: 가장 오랫동안 사용되지 않은 페이지를 교체
    - 특징: <a href="https://en.wikipedia.org/wiki/Locality_of_reference">프로그램의 지역성 원리</a>를 잘 활용하나, 구현이 복잡하고 오버헤드가 있을 수 있음 
  - LFU (Least Frequently Used)
    - 원리: 가장 적게 사용된 페이지를 교체합니다.
    - 특징: 사용 빈도를 추적해 초기에 자주 사용되었던 페이지가 장기적으로 사용되지 않더라도 메모리에 남아있을 수 있습니다. 
  - NRU (Not Recently Used)
    - 원리: 최근에 사용되지 않은 페이지 중 하나를 무작위로 교체합니다.
    - 특징: 구현이 간단하며, 일반적인 성능이 좋습니다.
  - Clock (Second Change Algorithm)  
    - 원리: FIFO에 사용됨 플래그를 추가해 구현합니다. 페이지에 두 번째 기회를 주어 사용됨 플래그가 설정된 페이지는 플래그를 해제하고 다시 순환하도록 합니다.
    - 특징: LRU의 <a href="https://ko.wikipedia.org/wiki/%EA%B7%BC%EC%82%AC_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98">근사 알고리즘</a>으로, 구현이 간단하고 효과적입니다.
  - Optimal Page Replacement
    - 원리: 미래에 가장 오랫동안 사용되지 않을 페이지를 교체합니다.
    - 특징: 이론적 모델로 실제 시스템에서는 미래의 참조를 예측 할 수 없기에 구현 할 수 는 없습니다. 

    





