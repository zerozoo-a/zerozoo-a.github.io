---
title: 메모리 저장 방식인 페이지와 세그먼트
date: 2023-12-28 22:19:30
coverURL: 
---
<br />
<br />
<br />

# 페이지와 세그먼트

페이지와 세그먼트는 os가 **메모리를 관리하는 방식**입니다.

페이지와 세그먼트는 각각 관리 방식에 차이를 가집니다.

## 고정크기의 페이지(Page)

- 페이지는 메모리를 고정된 크기의 블록으로 나눕니다.
    - 일반적으로 킬로바이트, 메가바이트 크기를 가집니다.
- 주로 가상 메모리에 사용됩니다.
    1. 프로그램이 여러 페이지로 나뉘어집니다. 
    2. 필요에 따라 실제 물리 메모리에 적재됩니다.
- 가상 주소를 물리 주소로 변환하기 위한 테이블을 사용합니다.
- 고정된 크기에 의해 내부 단편화 문제가 발생할 수 있습니다. 

## 가변크기의 세그먼트(Segment)

- 세그먼트는 메모리를 가변적인 크기의 블록으로 나눕니다.
  - 프로그램의 논리적 단위를 기반으로 크기가 정해집니다. 
    - 예를 들어 함수, 배열, 객체, 프로시저, 스택, 자료구조 등이 세그먼트로 구분됩니다. 

- 프로그램의 논리적 구조를 메모리에 반영합니다.
  - 디버깅에 직관적입니다. 

- 가변적인 크기를 설정하기 때문에 메모리 상에서 사용되지 않는 공간 낭비가 발생 할 수 있습니다.

- 세그먼트의 물리적 주소와 크기 정보를 보관하기 위해 가상 주소를
물리주소로 변환하는 테이블을 사용합니다.

- 세그먼트 메모리 관리는 프로그램의 논리적 구조를 반영합니다.
  - 세그먼트로 나누어진 메모리들 중 하나의 세그먼트는 힙 메모리일 수 있습니다.

- 세그먼트 테이블을 가지는 시스템에서 논리 주소(s, d)가 주어지면
논리주소 (s)에 속하는 세그먼트 테이블에서 s에 속하는 해당 base주소를 찾고,
해당 base 주소에 변위 d값을 더해줘서 물리주소를 계산합니다.

### 세그먼트 테이블 예시

세그먼트 테이블은 각 세그먼트의 시작 주소와 길이를 관리합니다. 

아래는 이를 나타낸 예시 표입니다.

| 세그먼트 번호 | 시작 주소 (Base) | 길이 (Limit) |
|--------------|------------------|--------------|
| 0            | 0x0000           | 0x1000       |
| 1            | 0x1000           | 0x2000       |
| 2            | 0x3000           | 0x1000       |
| 3            | 0x4000           | 0x3000       |

- **세그먼트 번호**: 프로세스 내 각 세그먼트를 식별하는 번호입니다.
- **시작 주소 (Base)**: 해당 세그먼트의 물리적 메모리 시작 주소입니다.
- **길이 (Limit)**: 세그먼트의 길이를 나타내며, 시작 주소로부터 얼마나 많은 메모리가 할당되었는지를 나타냅니다.

이 표는 각 세그먼트가 메모리 상에서 어떻게 배치되어 있는지를 보여줍니다. 
예를 들어, 세그먼트 번호 0은 물리적 주소 0x0000부터 시작하여, 0x1000 크기의 메모리를 차지합니다.


### 세그먼트 테이블 찾아가보기

세그먼트 테이블은 pagination과 비슷합니다.

세그먼트 번호와 오프셋이 주어지면 아래의 테이블에서 
메모리 주소를 찾아가고 저장 가능한지 확인 할 수 있습니다.

| 세그먼트 번호 | 시작 주소 (Base) | 길이 (Limit) |
|--------------|------------------|--------------|
| 0            | 0x0000           | 0x1000       |
| 1            | 0x1000           | 0x2000       |
| 2            | 0x3000           | 0x1000       |
| 3            | 0x4000           | 0x3000       |

- 세그먼트 번호: 2
- 오프셋: 0x0800
을 예시로 들겠습니다.

1. 세그먼트 확인: 테이블에서 세그먼트 번호를 찾아갑니다.

2. 오프셋 검증: 시작 주소가 0x3000입니다.
해당 세그먼트의 길이가 0x1000으로 오프셋은 
유효 범위 내에 있습니다.

3. 논리주소를 물리주소로 변환하기: 논리주소의 물리적 주소를 찾아가기 위해 세그먼트의 시작 주소에 오프셋을 더합니다.
  - 물리주소 = 세그먼트의 시작주소 + 오프셋입니다.
  - 0x3000 + 0x08000 = 0x38000

논리주소는 (2, 0x0800)입니다.
물리주소는 0x38000입니다.

만약 오프셋이 세그먼트 테이블의 길이를 넘으면 적재 할 수 없게 됩니다.


## 페이지와 세그멘테이션 혼용 기법

- 페이지의 외부 단편화, 세그멘테이션의 내부 단편화 문제를 최소화 하기 위해 개발됨
- 세그멘트로 메모리를 나눈 후, 세그먼트 내부에서 동일한 크기로 페이징하는 기법이다.
